
电 子 科 技 大 学 实   验   报   告  一、实验一：图书销售管理系统数据库SQL应用编程 二、实验室名称：					           实验时间：2019.06.14      三、实验目的 针对图书销售管理数据库开发，了解SQL语言DDL、DML、DQL类型语句在数据库操作访问中的应用方法，培养数据库SQL编程访问能力。同时也掌握基本的数据库触发器、存储过程SQL编程方法，培养数据库后端编程能力。本实验完成图书销售管理系统数据库的SQL数据操作访问和后端数据处理功能。 四、实验原理 数据库创建SQL语句基本格式： CREATE  DATABASE  <数据库名>; 数据库表创建SQL语句基本格式： CREATE TABLE  <表名>  （ <列名1>  <数据类型>  [列完整性约束]， 	  <列名2>  <数据类型>   [列完整性约束]，	     <列名3>  <数据类型>  [列完整性约束]，     …     CONSTRAINT  <约束名>  PRIMARY Key(主键列)    )；  索引（Index）是一种按照关系表中指定列的取值顺序组织元组数据存储的数据结构，使用它可以加快表中数据的查询访问。索引作用有支持对数据库表中数据快速查找，其机理类似图书目录可以快速定位章节内容。索引优点有提高数据检索速度，可快速连接关联表，减少分组和排序时间。索引开销为创建和维护索引都需要较大开销，索引会占用额外存储空间，数据操纵因维护索引带来系统性能开销。 索引创建SQL语句基本格式： CREATE INDEX  <索引名>  ON <表名><（列名）>； 索引修改SQL语句基本格式： ALTER  INDEX  <索引名> <修改项>； ALTER  INDEX  <索引名> RENAME TO <新索引名>； 索引删除SQL语句基本格式： DROP  INDEX  <索引名> ；  数据插入SQL语句基本格式 INSERT  INTO  <表名|视图名>[<列名表>]  VALUES （列值表）; 数据更新SQL语句基本格式 UPDATE  <表名|视图名> SET  <列名1>=<表达式1> [，<列名2>=<表达式2>...] [WHERE   <条件表达式>]； 数据删除SQL语句基本格式 DELETE  FROM  <表名|视图名> [WHERE   <条件表达式>]； 数据查询SQL语句格式 SELECT  [ALL|DISTINCT]  <目标列>[，<目标列>…] [ INTO <新表> ] FROM  <表名|视图名>[，<表名|视图名>…] [ WHERE  <条件表达式> ] [ GROUP BY  <列名> [HAVING <条件表达式> ]] [ ORDER BY  <列名> [ ASC | DESC ] ]; 在WHERE子句中可以使用如下方式，指定范围数据。 使用BETWEEN..AND关键词来限定列值范围，还可以使用关键词LIKE与通配符来限定查询条件。 使用通配符来限定字符串数据范围。下划线（_）通配符用于代表一个未指定的字符。百分号（%）通配符用于代表一个或多个未指定的字符。 在SQL查询Where子句中，还可以使用多个条件表达式，并通过逻辑运算符（AND、OR、NOT）连接操作，以及使用IN或NOT IN关键词，进一步限定结果集的数据范围。 如果结果集需要按多个列排序，可以分别加入关键字ASC或DESC改变。  子查询SQL语句基本格式： SELECT    <目标列>[，<目标列>…] FROM  <表名> WHERE  <条件中嵌套另一关系表的SELECT 查询结果集>  视图――是一种通过基础表或其它视图构建的虚拟表。它本身没有自己的数据，而是使用了存储在基础表中的数据。 视图创建SQL语句基本格式 CREATE  VIEW  <视图名>[(列名1)，(列名2)，…]  AS  <SELECT查询>； 视图删除基本格式 DROP  VIEW  <视图名>；  存储过程（Stored Procedure）是一种数据库的对象；由一组能完成特定功能的SQL 语句集构成；是把经常会被重复使用的SQL语句逻辑块封装起来，经编译后，存储在数据库服务器端；当被再次调用时，而不需要再次编译；当客户端连接到数据库时，用户通过指定存储过程的名字并给出参数，数据库就可以找到相应的存储过程予以调用。PostgreSQL使用CREATE FUNCTION命令创建存储过程。 创建存储过程的语法 CREATE [ OR REPLACE ] FUNCTION  name     ( [ [ argmode ] [ argname ] argtype [ { DEFAULT | = } default_expr ] [, ...] ] )     [ RETURNS retype | RETURNS TABLE ( column_name column_type [, ...] ) ] AS $$         //$$用于声明存储过程的实际代码的开始 DECLARE         -- 声明段 BEGIN         --函数体语句 END; $$ LANGUAGE lang_name;  //$$ 表明代码的结束, LANGUAGE后面指明所用的编程语言 在查询窗口执行存储过程，语法形式如下：  select 存储过程名（参数）； 存储过程调用其它存储过程，语法形式如下： select  into 自定义变量  from 存储过程名（参数）；  触发器是特殊类型的存储过程，主要由操作事件(INSERT、UPDATE、DELETE) 触发而被自动执行。触发器可以实现比约束更复杂的数据完整性，经常用于加强数据的完整性约束和业务规则。触发器本身是一个特殊的事务单位。与表相关联：必须定义在表或视图上。自动触发：由执行INSERT、DELETE、UPDATE操作时触发。不能直接调用，也不能传递或接受参数。是事务的一部分：触发器和触发语句作为可在触发器内回滚的单个事务。  按触发的语句分为： INSERT触发器、DELETE触发器、UPDATE触发器  触发器执行的次数可分： 语句级触发器，行级触发器。 按触发的时间分为三类：  （1）BEFORE触发器：在触发事件之前执行触发器。 （2）AFTER触发器：在触发事件之后执行触发器。 （3）INSTEAD OF触发器：当触发事件发生后，执行触发器中指定的函数，而不是执行产生触发事件的SQL 语句，从而替代产生触发事件的SQL操作。 PostgreSQL创建触发器的基本语法 CREATE  TRIGGER  触发器名        { BEFORE | AFTER | INSTEAD OF }      ON 表名      [ FOR [ EACH ] { ROW | STATEMENT } ]      EXECUTE PROCEDURE 存储过程名 ( 参数列表 ) PostgreSQL创建触发器的基本步骤： （1）检查数据库中将要创建的触发器所依附的表或视图是否存在，如果不存在，必须首先创建该表或视图。 （2）创建触发器被触发时所要执行的触发器函数，该函数的类型必须是TRINGER型，是触发器的执行函数。但要注意，有些数据库不需要独立定义触发器函数，而是在创建触发器时，定义触发器的过程体。 （3）创建触发器，一般需要指明触发器依附的表，触发器被触发执行的时间，触发器是行级触发器还是语句级触发器，触发器执行需要满足的条件 五、实验内容 使用pgAdmin4数据库管理工具对图书销售管理系统数据库进行SQL编程操作，并完成触发器、存储过程后端编程，具体实验内容如下: （1）图书销售管理系统数据库BookSale创建操作 （2）在图书销售管理系统数据库BookSale中创建数据库表、视图、索引等对象 （3）对图书销售管理系统数据库表进行数据增、删、查、改SQL操作 （4）编写函数Pro_CurrentSale，实现当日图书销售量及销售金额汇总统计。 （5）编写过程语句块，实现对函数Pro_CurrentSale的调用，并输出统计结果。 （6）编写图书销售表Insert触发器Tri_InsertSale，实现图书库存数据同步修改处理。 （7）对图书销售表Insert触发器Tri_InsertSale程序进行功能验证。 在实验计算机上，利用pgAdmin4数据库管理工具及SQL语句，完成图书销售管理系统数据库SQL应用编程操作，同时记录实验过程的步骤、操作、运行结果界面等数据，为撰写实验报告提供素材。 六、实验设备及环境 “数据库原理及应用”实验所涉及的机房硬件设备为pc计算机、服务器以及网络环境，pc计算机与服务器在同一局域网络。 操作系统： Windows7 / Windows XP 管理工具： pgAdmin4 DBMS系统： PostgreSQL 11 七、实验步骤 设计BookSale数据库。 创建BookSale数据库，使用pgadmin4中的图形化界面或者执行CREATE DATABASE BookSale;创建数据库。 根据BookSale数据库设计，编写SQL语句定义数据表项，列约束和表约束，创建相应的数据表。 为个每个表的主键建立索引。 建立视图方便，对数据信息的全部的查询。 向创建的各个数据表插入样例数据。 对数据表进行增、删、改、查操作。 编写函数Pro_CurrentSale，实现当日图书销售量及销售金额汇总统计，并调用输出统计结果。 编写图书销售表Insert触发器Tri_InsertSale，实现图书库存数据同步修改处理，并验证。 八、实验数据及结果分析 创建数据库 创建数据库，如下图所示，在pgadmin4中创建数据库，输入数据库名BookSale，点击save创建数据库。或者直接执行SQL语句：CREATE DATABASE BookSale;创建数据库。  图 1 创建数据库 如下图所示，成功创建BookSale数据库。  图 2 成功创建数据库      创建数据表 在BookSale数据库中启动query tool，写入SQL语句，创建BookSale数据库中相应的数据表。 Author表代表图书的作者实体，包括AuthorId,AuthorName,AuthorTel三项属性，其中AuthorId为主键。 Press代表图书出版社的实体，包括PressId，PressName，PressTel，PressAdd四项属性，其中PressId为主键。 Book代表图书实体，包括ISBN，PressId，BookName，Price四项属性，其中ISBN为主键唯一标识图书，PressId作为外键关联Press表确定出版社。 Complie是表示图书与作者之间的关系，往往一个图书会存在多个作者，每个作者又会写过多本书，因此添加Complie表来关联图书与作者。其中AuthorId，ISBN作为共同主键，又分别作为关联Author表和ISBN表的外键。 Inventory表记录库存ISBN既作为主键，有关联Book表的ISBN，Quantity记录该种书的库存值。 Sale表存储销售记录，SaleId作为自增长主键，ISBN关联Book表的ISBN，SaleDate表明销售日期，SaleQuantity表明销售的数量，SaleAmount表明销售的总金额。 编写SQL语句，创建数据表，源代码见下表。 表格 1 创建数据库表SQL源代码 向数据表中插入测试数据 如下表所示，插入数据的SQL源代码如下表所示。 表格 2 插入测试数据SQL语句 执行SQL语句向其中插入数据，运行结果如下图所示。  图 3 插入测试数据 创建索引和视图 执行上表中的创建数据表SQL文件，成功运行，成功创建数据表，如下图所示。  图 4 成功创建数据库表 为加快检索数据，因此为每个表的主键创建索引,如下图所示。  图 5 成功创建索引 为方便查看图书的详细内容创建BookDetailView视图，实现多表关联显示处Book的完整信息。如下图所示。  图 6 成功创建视图 使用视图，显示出图书的所有信息，如下图所示。  图 7 使用视图 对author表进行增删改查操作 查询Author表的全部记录，如下图所示。  图 8 查看Author表 对Author表增加一条记录，再查询整个表，可以看到，成功增添一条记录，如下图所示。 图 9 向Author表插入记录并验证 对Author表中的authorid为201911110006的记录进行修改，将authorname修改为张三，authortel修改为12345678910。执行SQL语句后，再次查询全表，可以发现修改成功，如下图所示。  图 10 对Author表进行更新操作并验证 对Author表中的authorid为201911110006的记录进行删除，执行SQL语句后，再次查询全表，可以发现成功删除该条记录。需要注意的是该条数据没有与具体的书籍关联，因此可以自由删除。若该作者与书籍存在关联，应先删除相应的书籍记录，才能删除该记录，如下图所示。  图 11 对Author表进行删除操作并验证 对Book表进行增删改查操作 查看Book表全部记录，如下图所示。  图 12 查询Book表 向Book表中添加一条记录，需要注意的是Book表中的pressid关联于Press表中的pressid存在外键约束，因此插入数据的pressid字段一定要存在于Press表中，执行插入SQL语句后，再次查询全表，插入数据成功，如下图所示。  图 13 向Book表插入数据并验证 修改刚插入的数据，修改价格为198.50，执行更新SQL语句，再次查询，修改成功，如下图所示。  图 14 更新Book表数据并验证 删除插入的记录，执行删除SQL语句，再次查询全表，删除成功。需要注意，Book表中的主键isbn被Inventory表作为外键关联约束，因此在删除某一条书籍记录时，要首先删除Inventory表中的库存记录，也可以在定义表的时候定义级联操作，如下图所示。  图 15 删除Book表数据并验证      编写函数Pro_CurrentSale，实现当日图书销售量及销售金额汇总统计 编写函数Pro_CurrentSale，实现当日图书销售量及销售金额汇总统计，SQL源代码如下图所示。 表格 3 Pro_CurrentSale()函数源代码 创建Pro_CurrentSale函数，调用该函数，显示出当日的总销量和总销售金额，如下图所示。  图 16 创建Pro_CurrentSale()函数并调用 显示Sale全表，可以验证，Pro_CurrentSale正确显示出当日的总销量和总销售金额，如下图所示。  图 17 验证Pro_CurrentSale()函数正确性 编写图书销售表Insert触发器Tri_InsertSale，实现图书库存数据同步修改处理。 首先编写Sale_insert存储过程，实现Sale表售出书籍Inventory表的库存同步减少，再编写图书销售表Insert触发器Tri_InsertSale，当每次对Sale表进行插入操作时，对每条记录执行Sale_insert（）函数，实现图书库存数据同步修改处理。 表格 4 Tri_InsertSale触发器SQL源代码 执行Tri_InsertSale创建语句，如下图所示。  图 18 Tri_InsertSale创建 验证触发器是否正常 使用创建的BookDetailView视图，查看所有图书的详细信息，可以发现《现代密码学》、《汇编语言》、《数据库》这三本书的库存分别有20，5，60，如下图所示。  图 19 查看书籍库存 分别插入三本的的销售数据，其中《数据库》销售10本，《汇编语言》销售1本，《现代密码学》销售10本，再次利用BookDetailView视图查看书籍库存，《现代密码学》10本、《汇编语言》4本、《数据库》50本，符合要求库存进行了同步更新，如下图所示。  图 20 执行插入操作验证触发器 九、总结及心得体会 总结： 书和作者之间的关系是多对多，一个作者可能写了多本书，一本书可以有多个作者，因此为表示这种关系，应添加一个编著表，实现多对多的映射。 插入数据时，完整地插入数据直接使用INSERT INTO tablename VALUES (value,…)，若插入数据记录不包含全部列，需要在tablename后指明插入的列项。 在postgreSQL中函数就是存储过程，存储过程中就是一组SQL语句地集合，类似于其他语言中地函数一样。本次实验中Pro_CurrentSale()函数，实际上就是用SELECT查出Sale表的在当日产生所有数据记录，对SaleQuantity，SaleAmount分别求和就得到的统计值。由于需要返回两个值，因此返回类型可以是一个二维表结构。其中表项中的数据类型需要注意SaleQuantity求和后的值与本身的INT类型不同，而是BIGINT，SaleAmount求和后与本身相同仍是MONEY类型。 创建触发器可以分为两步，第一步是创建触发器执行函数，这个函数的创建和存储过程函数相差不大，必须指定函数返回的类型为trigger，触发器函数中有一些不需要声明的特殊变量，NEW：代表行级触发INSERT和UPDATE操作时的新数据行，TG_OP：代表触发器由哪个操作触发。 ；第二部是创建触发器，指明依附的表和被触发的时间是行级还是语句级，以及触发器执行需要满足的条件。本次实验中的触发器应该是在INSERT操作时触发，对于每行都要进行触发。 心得体会： 视图可以给用户带来很多地便利，第一是可以简化复杂地SQL操作，给我的感觉类似于函数，将复杂的操作封装在里面；第二是可以集中地展示特定地数据，例如本次实验中我们时常会去查看Book地相关信息，而这些信息又分散在不同地表中，使用视图可以将他们集成显示；第三是提高数据访问地安全性，用户就不知道完整地表项，数据会相对安全；第四点是具有一定地数据独立性，如果我采用视图去查询，真实地表项发生结果改变不会影响到我。 存储过程函数和触发器函数相同，都是对一组SQL语句的封装，再加上了一些控制分支语句。再编写的时候要注意函数的格式，函数的返回类型，参数的类型，其中的SQL语句就与普通的SQL语句相同。 
 电 子 科 技 大 学 实   验   报   告  一、实验二：图书销售管理系统数据库安全管理 二、实验室名称：  					          实验时间：2019.06.14      三、实验目的 了解该DBMS系统对数据库管理的内容与方法，特别是理解数据库安全机制和作用，以及PostgreSQL数据库角色管理、用户管理、权限管理的基本方法，培养数据库管理能力。在图书销售管理系统数据库中，创建必要的角色和用户，并完成上述角色与用户的权限管理。 四、实验原理 用户管理：在数据库安全管理中，DBMS需要对每个用户进行管理，如用户创建、用户修改、用户删除管理等。 实现用户管理方式：数据库服务器执行SQL语句管理用户，通过管理工具GUI操作管理用户。 用户创建SQL语句 CREATE USER  <用户账号名> [ [WITH]  option […]]; 用户修改SQL语句 ALTER USER  <用户名>  [ [ WITH ] option [ ... ] ];  	--修改用户的属性 ALTER USER  <用户名>  RENAME TO <新用户名>;  --修改用户的名称 ALTER USER  <用户名>  SET <参数项> { TO | = } { value | DEFAULT };--修改参数值   ALTER USER  <用户名>  RESET <参数项>;	--重置用户参数值 用户删除SQL语句 DROP  USER  <用户名>;  数据库权限管理是指DBA管理员或数据库对象拥有者对其所拥有对象进行权限控制设置 权限管理基本操作：授予权限、收回权限、拒绝权限。 权限类别：数据库系统权限、数据库对象访问操作权限、数据库对象定义操作权限。 权限管理SQL语句 GRANT  <权限名> ON  <对象名>  TO {数据库用户名|用户角色名}； REVOKE  <权限名> ON  <对象名>  FROM {数据库用户名|用户角色名}； DENY  <权限名> ON  <对象名> TO {数据库用户名|用户角色名}； 在DBMS中，为了方便对众多用户及其权限进行管理，通常将一组具有相同权限的用户定义为角色(Role)。 角色管理内容：创建角色、修改角色、删除角色。 角色管理实现方式：执行SQL语句管理角色，，通过GUI操作管理角色 角色管理SQL语句 CREATE  ROLE  <角色名> [ [ WITH ] option [ ... ] ]; --创建角色 ALTER  ROLE  <角色名>  [ [ WITH ] option [ ... ] ]; --修改角色属性 ALTER  ROLE  <角色名>  RENAME TO <新角色名>;  --修改角色名称  ALTER  ROLE  <角色名>  SET <参数项> { TO | = } { value | DEFAULT }; --修改参数 ALTER  ROLE  <角色名>  RESET <参数项>;--复位角色参数值 DROP  ROLE  <角色名>;	--删除指定角色 五、实验内容 使用pgAdmin4数据库管理工具对图书销售管理系统数据库进行数据库安全管理，具体实验内容如下: （1）针对图书销售管理系统数据库，设计数据存取权限控制模型。 （2）在数据库中，创建客户（R_Customer）、商家（R_Seller）角色。 （3）在数据库中，根据业务规则为客户（R_Customer）、商家（R_Seller）角色赋予数据库对象权限。 （4）在数据库中，分别创建客户用户U_Customer、商家用户U_Seller。 （5）分别为客户用户U_Customer、商家用户U_Seller分派客户（R_Client）、商家（R_Seller）角色。 （6）分别以客户用户U_Customer、商家用户U_Seller身份访问图书销售管理数据库，验证所实现数据存取权限控制模型的正确性。 在实验计算机上，利用pgAdmin4数据库管理工具及SQL语句，完成图书销售管理系统数据库安全管理，同时记录实验过程的步骤、操作、运行结果界面等数据，为撰写实验报告提供素材。  六、实验设备及环境 “数据库原理及应用”实验所涉及的机房硬件设备为pc计算机、服务器以及网络环境，pc计算机与服务器在同一局域网络。 操作系统： Windows7 / Windows XP 管理工具： pgAdmin4 DBMS系统： PostgreSQL 11 七、实验步骤 针对图书销售管理系统数据库，设计数据存取权限控制模型。 在数据库中，创建客户（R_Customer）、商家（R_Seller）角色。 在数据库中，根据业务规则为客户（R_Customer）、商家（R_Seller）角色赋予数据库对象权限。 在数据库中，分别创建客户用户U_Customer、商家用户U_Seller。 分别为客户用户U_Customer、商家用户U_Seller分派客户（R_Client）、商家（R_Seller）角色。 分别以客户用户U_Customer、商家用户U_Seller身份访问图书销售管理数据库，验证所实现数据存取权限控制模型的正确性。 八、实验数据及结果分析 针对图书销售管理系统数据库，设计数据存取权限控制模型，其权限模型中分为两个角色，客户是到店进行购买的角色，因此只能够对书籍的简单信息进行查看，对于库存和销售等无权查看；商家负责进货和销售对数据库有绝对的控制权，因此对所有表拥有全部权限，其权限控制模型如下表所示。 表格 5 权限控制模型 在数据库中，创建客户（R_Customer）、商家（R_Seller）角色。显然商家和客户角色都不是超级用户，只是数据库的使用者。使用CREATE ROLE 语句创建角色，其中需要指定一些参数：LOGIN允许角色登陆数据库，NOSUPERUSER不是超级用户，NOCRETAEDB没有创建数据库的权限，NOCRETAEROLE没有创建角色的权限，CONNECTION LIMIET C 不限制连接数。，执行结果如下图所示。  图 21 创建角色 在数据库中，根据业务规则为客户（R_Customer）、商家（R_Seller）角色赋予数据库对象权限。依照控制模型使用GRANT语句对角色赋予对应表相应的权限，如下图所示。  图 22 给角色赋予权限  在数据库中，分别创建客户用户U_Customer、商家用户U_Seller。使用CREATE USER 语句创建用户，其中需要指明用户登陆的密码，如下图所示。  图 23 创建用户 分别为客户用户U_Customer、商家用户U_Seller分派客户（R_Client）、商家（R_Seller）角色。给用户分派角色时，使用GRANT语句，如下图所示。  图 24 给用户分派角色 分别以客户用户U_Customer、商家用户U_Seller身份访问图书销售管理数据库，验证所实现数据存取权限控制模型的正确性。 验证用户U_Customer对author表的权限，如下图所示。因为该用户的权限只有查询，因此当执行插入、更新、删除操作时均被拒绝，只有查询操作能正常执行，符合权限要求。  图 25 客户对author表控制权限验证 验证用户U_Customer对press表的权限，如下图所示。因为该用户的权限只有查询，因此当执行插入、更新、删除操作时均被拒绝，只有查询操作能正常执行，符合权限要求。  图 26 客户对press表权限验证 验证用户U_Customer对book表的权限，如下图所示。因为该用户的权限只有查询，因此当执行插入、更新、删除操作时均被拒绝，只有查询操作能正常执行，符合权限要求。  图 27 客户对book表权限验证 验证用户U_Customer对complie表的权限，如下图所示。因为该用户的权限只有查询，因此当执行插入、更新、删除操作时均被拒绝，只有查询操作能正常执行，符合权限要求。  图 28 客户对compile表权限验证 验证用户U_Customer对inventory表的权限，如下图所示。因为该用户无权限，因此当执行查询、插入、更新、删除操作时均被拒绝，符合权限要求。  图 29 客户对inventory表权限验证 验证用户U_Customer对Sale表的权限，如下图所示。因为该用户无权限，因此当执行查询、插入、更新、删除操作时均被拒绝，符合权限要求。  图 30客户对sale表权限验证 验证用户U_Seller对author表的权限，如下图所示。因为该用户拥有全部权限，因此当执行查询、插入、更新、删除操作时均正确执行，符合权限要求。   图 31 商家对author表权限验证 验证用户U_Seller对press表的权限，如下图所示。因为该用户拥有全部权限，因此当执行查询、插入、更新、删除操作时均正确执行，符合权限要求。  图 32 商家对press表权限验证 验证用户U_Seller对book表的权限，如下图所示。因为该用户拥有全部权限，因此当执行查询、插入、更新、删除操作时均正确执行，符合权限要求。  图 33商家对book表权限验证 验证用户U_Seller对compile表的权限，如下图所示。因为该用户拥有全部权限，因此当执行查询、插入、更新、删除操作时均正确执行，符合权限要求。  图 34 商家对compile表权限验证 验证用户U_Seller对inventory表的权限，如下图所示。因为该用户拥有全部权限，因此当执行查询、插入、更新、删除操作时均正确执行，符合权限要求。  图 35 商家对inventory表权限验证 验证用户U_Seller对sale表的权限，如下图所示。因为该用户拥有全部权限，因此当执行查询、插入、更新、删除操作时均正确执行，符合权限要求。  图 36 商家对sale表权限验证 九、总结及心得体会 总结： 对用户赋予角色的操作可以有两种方式，第一种：在创建用户时就指明它是属于哪几种角色；第二种：是使用GRANT语句将角色赋给用户。 心得体会： 对数据库进行合理的权限管理是保证数据库安全的重要手段，建立权限控制模型时一定要符合业务逻辑。首先DBA拥有全部权限，对于商家、老板等用户可以将数据库的全部权限赋予，对于客户最多只能赋予某些表的查询权限，因为核心数据不能让所有的人都看到。