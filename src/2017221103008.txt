
电 子 科 技 大 学 实   验   报   告  一、实验一：图书销售管理系统数据库SQL应用编程 二、实验室名称：信软学院楼西303					实验时间：2019.6.14      三、实验目的 针对图书销售管理数据库开发，了解SQL语言DDL、DML、DQL类型语句在数据库操作访问中的应用方法，培养数据库SQL编程访问能力。同时也掌握基本的数据库触发器、存储过程SQL编程方法，培养数据库后端编程能力。本实验完成图书销售管理系统数据库的SQL数据操作访问和后端数据处理功能。 四、实验原理 1.首先对图书销售管理系统进行数据需求分析，定义组成系统数据结构的实 体、实体属性以及实体之间的关系。通过建模设计工具完成系统概念数据模型设 计。进一步对图书销售管理数据库进行物理模型设计，给出数据库设计方案。  2.基于数据库设计方案，通过 SQL 编程执行来完成对数据库的实现操作。在 本实验中，使用 SQL 语句完成对数据库、关系表、索引、视图、触发器、存储过 程的创建，并编写 SQL 语句对数据库表进行数据的增删查改操作，以及利用视图、 存储过程、触发器实现业务数据处理。 五、实验内容 使用pgAdmin4数据库管理工具对图书销售管理系统数据库进行SQL编程操作，并完成触发器、存储过程后端编程，具体实验内容如下: 1.在数据库服务器中，执行SQL创建图书销售管理系统数据库BookSale。 2.在数据库BookSale中，执行SQL创建数据库表、视图、索引等对象。 3.在数据库BookSale中，执行SQL进行数据增、删、查、改访问操作。 4.在数据库BookSale中，采用PL/pgSQL语言编写存储过程函数Pro_CurrentSale，实现当日图书销售量及销售金额汇总统计。 5.在数据库BookSale中，采用PL/pgSQL语言编写过程语句块，实现对存储过程函数Pro_CurrentSale的调用，并输出统计结果。 6.在数据库BookSale中，采用PL/pgSQL语言编写编写图书销售表Insert触发器Tri_InsertSale，实现图书库存数据同步修改处理。 7.在数据库BookSale中，对图书销售表Insert触发器Tri_InsertSale程序进行功能验证。 8.在数据库BookSale中，创建存储过程函数实现图书销售数量和金额统计。 在实验计算机上，利用pgAdmin4数据库管理工具及SQL、PL/pgSQL语言，完成图书销售管理系统数据库应用编程操作，同时记录实验过程的步骤、操作、运行结果界面等数据，为撰写实验报告提供素材。 六、实验设备及环境 “数据库原理及应用”实验所涉及的机房硬件设备为pc计算机、服务器以及网络环境，pc计算机与服务器在同一局域网络。 操作系统： Windows7 / Windows XP 管理工具： pgAdmin4 DBMS系统： PostgreSQL 11 七、实验步骤 1. 在数据库服务器中，采用 SQL 语句执行方式，创建图书销售管理系统数 据库 BookSale。 2.在 BookSale 数据库中，采用 SQL 语句执行方式，创建 book（图书表）、 auther （作者表）、publisher（出版社表）、stock（库存流水表）、customer（客户表）、 sale（销售表），以及各表主键外键的创建，并为给表创建索引。  3.为 book、auther、publisher、customer 表准备样本数据，采用 SQL 语句执 行方式，将样本数据插入到表中。采用 SQL 语句对 book、auther、publisher、 customer 表进行数据修改、删除、查询、统计等访问操作。  4.创建视图 BOOK_AUTHER_PUBLISHER，该视图查询数据库，输出图书名、 作者、出版社以及图书价格等数据。对视图 Book_View 进行数据查询访问操作。  5.编写触发器函数，实现在 sale 表数据插入时，级联操作 stock 表，将图书 的库存流水进行记录，同时级联更新 book 表中对应图书的库存数据。  6.创建完触发器函数之后，创建相对应的触发器，实现上一步中提到的功能。  7.测试触发器的功能，准备 sale 表的样本数据，并将其插入 sale 表，插入之 后查看 stock 表是否有对应的更新，并对比插入 sale 数据前后 book 中对应数据 的修改情况。  8.编写存储过程函数，实现统计某日图书的销售总量以及总金额数据。  9.调用存储过程函数，查看输出结果是否准确实现业务数据处理功能。 八、实验数据及结果分析 1. 创建 BookSale 数据库 实现思路与方法：使用 SQL 语句来进行数据库的创建。 SQL 语句：create database "BookSale" 运行操作界面如图 1-1 所示。 图 1-1 创建数据库 数据库操作结果面如图 1-2 所示。  图 1-2 数据库创建完成 结果分析：成功创建数据库。 2. 创建各数据库表以及表中主外键和索引 实现思路与方法：首先明确图书销售管理系统的实体、实体属性以及各实体 之间的联系，再通过 SQL 语句对表进行创建，表对应实体，实体属性对应表中 的列，通过主外键来将表联系起来。 SQL 语句：  create table Auther ( AU_ID CHAR(18) not null, AU_Name VARCHAR(20) not null, AU_Gender CHAR(2) not null, AU_Phone VARCHAR(11) not null, AU_Address VARCHAR(50) not null, constraint PK_AUTHER primary key (AU_ID) ); create table Book ( Book_ISBN CHAR(13) not null, AU_ID CHAR(18) null, PUB_ID CHAR(11) null, Book_Name VARCHAR(50) not null, Book_Pubdate DATE not null, Book_Price MONEY not null, Book_Category VARCHAR(20) not null, Book_Stock INT4 not null, Book_Notes VARCHAR(100) null, Book_List VARCHAR(100) null, constraint PK_BOOK primary key (Book_ISBN) ); create table CUSTOMER ( CUST_ID CHAR(18) not null, CUST_Name VARCHAR(20) not null, CUST_Phone VARCHAR(15) not null, CUST_Address VARCHAR(50) not null, CUST_Email VARCHAR(50) not null, constraint PK_CUSTOMER primary key (CUST_ID) ); create table Publisher ( PUB_ID CHAR(11) not null, PUB_Name VARCHAR(20) not null, PUB_Phone VARCHAR(15) not null, PUB_Address VARCHAR(50) not null, constraint PK_PUBLISHER primary key (PUB_ID) ); create table Sale ( SALE_ID VARCHAR(11) not null, Book_ISBN CHAR(13) null, CUST_ID CHAR(18) null, SALE_Date DATE not null, SALE_QTY INT4 not null, SALE_Amount MONEY not null, constraint PK_SALE primary key (SALE_ID) ); create table Stock ( Stock_ID VARCHAR(10) not null, Book_ISBN CHAR(13) null, Stock_Change INT4 not null, Stock_Operation CHAR(4) not null, Stock_Datetime DATE not null, constraint PK_STOCK primary key (Stock_ID) ); alter table Book add constraint FK_BOOK_BOOK_AUTH_AUTHER foreign key (AU_ID) references Auther (AU_ID) on delete restrict on update restrict; alter table Book add constraint FK_BOOK_BOOK_PUBL_PUBLISHE foreign key (PUB_ID) references Publisher (PUB_ID) on delete restrict on update restrict; alter table Sale add constraint FK_SALE_BOOK_SALE_BOOK foreign key (Book_ISBN) references Book (Book_ISBN) on delete restrict on update restrict; alter table Sale add constraint FK_SALE_CUSTOMER__CUSTOMER foreign key (CUST_ID) references CUSTOMER (CUST_ID) on delete restrict on update restrict; alter table Stock add constraint FK_STOCK_BOOK_STOC_BOOK foreign key (Book_ISBN) references Book (Book_ISBN) on delete restrict on update restrict; 将上面的 SQL 程序，提交到数据库服务器执行，其执行作界面如图 1-3 所示。  图 1-3 创建数据库表 SQL 程序执行结果 当 SQL 程序成功执行后，可以在数据库看到新添加的数据库表对象，如图 1-4 所示。  图 1-4 图书销售数据库表对象  结果分析：成功创建各数据库表。 3. 插入样本数据并对 publisher 表进行增删查改操作 实现思路与方法：首先准备样本数据，尽可能使得数据符合实际应用并且要 能满足后续的数据处理操作。这里以 publisher 表为例，给出该表的数据增、删、 查、改 SQL 语句操作访问。  1）执行 SQL 语句，插入样本数据到图书销售数据库  Insert into Auther values('330309198504150527','王天','男','13554874593','四川省成都市成华区建设北路 二段十号');  Insert into Auther values('540135199103281548','叶无双','男','15812387538','浙江省杭州市天路区梅田路 二十八号');  Insert into Auther values('120857198811123587','李婷','女','18575615472','北京市朝阳区梅山路二巷八号 ');  Insert into PUBLISHER values('PUB00000001','高等教育出版社','010-65321854','北京');  Insert into PUBLISHER values('PUB00000002','电子工业出版社','010-65329857','北京');  Insert into PUBLISHER values('PUB00000003','人民邮电出版社','010-65325987','北京');  InsertintoBOOKvalues('9787115502742','330309198504150527','PUB00000001','Web 前端开发最佳实践 ','2016-01-01','59','IT 技术','100');  InsertintoBOOKvalues('9875325415577','540135199103281548','PUB00000002','Java EE Web 编 程','2008-01-01','52','IT 技术','200');  Insertinto BOOK values('9865365975234','120857198811123587','PUB00000003',' 数 据 库 实 验 指 导 ','2013-08-1','29','IT 技术','150');  Insert into customer values('680554199207120325','林天','15963512578','四川省成都市成华区建设北路二 段十一号','450448745@qq.com');  Insert into customer values('345021198608120258','宫铃','18636598574','浙江省杭州市天路区梅田路二十 九号','657873215@qq.com');  Insert into customer values('542244197812121687','鲁丽','13615869875','北京市朝阳区梅山路二巷十六号 ','647864378@qq.com');  样本数据插入 SQL 程序的运行操作界面如图 1-5 所示。  图 1-5 插入样本数据 SQL 程序执行 查看 publisher 表数据的 SQL 语句如下： select*frompubliser; 运行该 SQL 语句，其执行结果如图 1-6 所示。  图 1-6 查询 publisher 表数据 结果分析：插入表数据成功无误。 2）增加一条数据到 publisher 表 SQL 语 句 ： Insert into PUBLISHER values('PUB00000004',' 清 华 大 学 出 版 社 ','010-65323169','北京'); 运行操作界面如图 1-7 所示。  图 1-7 插入一条新数据到 publisher 表 执行结果如图 1-8 所示。  图 1-8 查询插入新数据之后的 publisher 表  结果分析：插入表数据成功。 3）删除一条publisher 表数据 SQL语句： Delete from publisher where pub_id='PUB00000004'; 运行操作界面如图 1-9 所示。  图 1-9 删除 publisher 表的一条数据 其执行结果如图 1-10 所示。  图 1-10 查询删除数据后的 publisher 表 结果分析：确实删除掉了对应的 pub_id 的数据，删除操作执行成功。 4）修改一条 publisher 表数据 SQL 语句：update publisher set pub_address='南京'where pub_id='PUB00000003'; 该语句运行操作结果如图 1-11 所示。  图 1-11 更新 publisher 表的一条数据 再对 publisher 进行查询，其执行结果如图 1-12 所示。  图 1-12 查询更新数据后的 publisher 表 结果分析：对应 pub_id 的数据确实被成功修改。 4.创建视图 实现思路与方法：创建一个视图将多个表关联查询，通过视图实现简单的数 据查询。创建完视图之后可用 select 语句来查看视图，用法：select *from 视图 名。例如，创建视图 BOOK_AUTHER_PUBLISHER 实现图书信息查询，其 SQL 语句如下： create view BOOK_AUTHER_PUBLISHER as select B.book_name as "图书",AU.au_name as"作者",PU.pub_name as"出版社",B.book_price as "图书价格" from book as Bjoin auther as AU on B.au_id=AU.au_id join publisher as PU on B.pub_id=PU.pub_id 该 SQL 运行操作结果如图 1-13 所示：  图 1-13 创建视图 采用如下 SQL 语句实现视图数据查询： select*from BOOK_AUTHER_PUBLISHER; 该 SQL 语句执行结果如图 1-14 所示。  图 1-14 查看视图 结果分析：视图展示数据对应正确且按需展示，视图创建成功。 5.创建触发器函数 实现思路与方法：创建触发器函数实现在有一条销售数据插入 sale 表时，同 时在库存表 stock 中插入图书的库存变化记录，并修改对应图书表 book 的库存 数，为后续的创建触发器提供函数方法。创建触发器函数 SQL 语句：  CREATE OR REPLACE FUNCTION InsertSale()RETURNS TRIGGER AS $$  BEGIN  IF(TG_OP='INSERT')THEN 	 INSERT INTO stock values(new.sale_id,new.book_isbn,new.sale_qty,'出库',new.sale_date);  update book set book.book_stock = book.book_stock - new.sale_qty where book.book_isbn = new.book_isbn;  RETURN NEW;  END IF;  RETURN NULL;  END;  $$ LANGUAGE plpgsql; 运行操作界面如图 1-15 所示。  图 1-15 创建触发器函数 6. 创建触发器 实现思路与方法：创建触发器，关联销售表，在销售表插入一个新数据之后， 执行上一步编写的触发器函数。 创建触发器 SQL 语句：  CREATE TRIGGER Tri_InsertSale  AFTER INSERT ON SALE  FOR EACH ROW EXECUTE PROCEDURE InsertSale(); 运行操作界面如图 1-16 所示。  图 1-16 创建触发器 7. 测试触发器 实现思路与方法：在销售表中插入几个样本数据，之后再查看库存表和图书 表的数据，观察这两个表中的数据是否发生变化，并且观察数据的变化是否与插 入销售表的数据一致.测试触发器 SQL 语句：  Insert into sale values('SA00001','9787115502742','680554199207120325','2019-05-20',15,'885');  Insert into sale values('SA00002','9875325415577','345021198608120258','2019-05-20',20,'1040');  Insert into sale values('SA00003','9865365975234','542244197812121687','2019-05-20',50,'1450'); 运行操作界面如图 1-17 所示。  图 1-17 触发器创建成功 结果展示，查看 stock 表数据以及对比 book 表数据。 Stock 表数据如图 1-18 所示。  图 1-18 查看测试触发器之后的 stock 表数据 Book 表之前的数据如图 1-19 所示。  图 1-19 查看 book 表在测试触发器之前的数据 触发器执行之后的 book 表数据如图 1-20 所示。  图 1-20 查看 book 表在测试触发器之后的数据 结果分析： Stock 表本来没有数据，在 sale 插入数据之后，将库存数据进行记录，记录数据 正确，同时更新了 book 表中各对应图书的库存量，更新数据正确，触发器功能 实现正确。 8. 创建存储过程 实现思路与方法：通过存储过程实现某日图书销售数量和金额统计。创建存储过程的 SQL 语句如下。 CREATE OR REPLACE FUNCTION countsale(OUT amountint,OUT allmoneymoney) as$count$  BEGIN  Select sum(sale_qty) into amount FROM sale WHERE sale_date= '2019-05-20';  Select sum(sale_amount)into allmoney FROM sale WHERE sale_date='2019-05-20';  END;  $count$ LANGUAGE plpgsql; 该 SQL 语句运行操作界面如图 1-21 所示。  图 1-21 创建存储过程 9. 调用存储过程 实现思路与方法：调用上一步的存储过程，观察输出的结果是否与真实情况 一致，调用存储过程 SQL 语句如下： Select*from count sale() 存储过程调用语句执行结果如图 1-22 所示。  图 1-22 调用存储过程 结果分析：调用存储过程输出的总销售量和总金额数据正确，存储过程功能正确 九、总结及心得体会   本次实验对我来说主要是学会了数据库的基本用法，比如说创建数据库，创建表格。还有一些其他的数据库的基本操作，比如说表格数据的增删查改，创建为视图后的增删查改，都是对数据库的基本操作，但这些却极为重要，因为这些基本操作是非常基本的，但却会让数据库的结构产生一些重大的变化。这个实验稍微复杂点的东西就是触发器函数和存储过程的构建，最主要的就是这个触发器的构建让我对数据库有了新的认识，是一个很奇妙的结构，经过这次实验后，我对数据库的兴趣浓厚了许多。
 电 子 科 技 大 学 实   验   报   告  一、实验二：图书销售管理系统数据库安全管理 二、实验室名称： 信软学院楼西303 		  实验时间：2019.6.21 三、实验目的 了解该DBMS系统对数据库管理的内容与方法，特别是理解数据库安全机制和作用，以及PostgreSQL数据库角色管理、用户管理、权限管理的基本方法，培养数据库管理能力。在图书销售管理系统数据库中，创建必要的角色和用户，并完成上述角色与用户的权限管理。 四、实验原理 1.设计数据存取权限控制模型，对各角色进行不同权限的赋予，保证数据库 数据的安全性。  2.使用 SQL 语句进行角色、用户的创建、对角色进行权限赋予、对用户分派 角色。  3.使用不同的用户登录时，就拥有了该用户的权限，在对数据库表进行操作 的时候就会受到不同程度的制约 五、实验内容 使用pgAdmin4数据库管理工具对图书销售管理系统数据库进行数据库安全管理，具体实验内容如下: 1.针对图书销售管理系统数据库，设计数据存取权限控制模型。 2.在数据库中，创建客户（R_Customer）、商家（R_Seller）角色。 3.在数据库中，根据业务规则为客户（R_Customer）、商家（R_Seller）角色赋予数据库对象权限。 4.在数据库中，分别创建客户用户U_Customer、商家用户U_Seller。 5.分别为客户用户U_Customer、商家用户U_Seller分派客户（R_Client）、商家（R_Seller）角色。 6.分别以客户用户U_Customer、商家用户U_Seller身份访问图书销售管理数据库，验证所实现数据存取权限控制模型的正确性。 在实验计算机上，利用pgAdmin4数据库管理工具及SQL语句，完成图书销售管理系统数据库安全管理，同时记录实验过程的步骤、操作、运行结果界面等数据，为撰写实验报告提供素材。 六、实验设备及环境 “数据库原理及应用”实验所涉及的机房硬件设备为pc计算机、服务器以及网络环境，pc计算机与服务器在同一局域网络。 操作系统： Windows7 / Windows XP 管理工具： pgAdmin4 DBMS系统： PostgreSQL 11 七、实验步骤 1.针对图书销售管理系统，在设计数据存取权限控制模型。  2.在 pgAdmin4 中 的 BookSale 数 据 库 中 ， 使 用 SQL 语 句 创 建 客 户 （R_Customer）角色、商家（R_Seller）角色。  3.在 pgAdmin4 中，根据第一步设计的数据存取权限控制模型对客户 （R_Customer）角色、商家（R_Seller）角色赋予所定义的数据库对象权限。  4.在 pgAdmin4 中，分别创建客户用户 U_Customer、商家用户 U_Seller，并 为客户用户分配客户角色，为商家用户分配商家角色。  5.分别以客户用户 U_Customer、商家用户 U_Seller 身份访问图书销售管理 数据库，并分别以这两个用户对各数据库表进行操作，以验证是否正确分配了两 用户不同的角色权限 八、实验数据及结果分析 1.针对图书销售管理系统，设计数据存取权限控制模型。 实现思路与方法：针对图书销售管理系统，主要的是两个角色，客户和商家， 客户角色对于任何的数据表都最多只有读取权限，而图书的销售信息、库存流水 信息和其他客户的信息都不应该被客户查看到。因此客户角色对于整个系统只有 查看图书、作者、出版社表的权限。而商家角色则具有对除了库存表以外，具有 所有表的增删查改权限。因为库存表的数据都是根据销售表来进行变化的，所以 对库存表只有查看权限。他们的数据库存取访问权限控制模型设计如图 2-1 与图 2-2 所示。  图 2-1 客户角色安全模型  图 2-2 商家角色安全模型 2.创建客户角色和商家角色 实现思路与方法：使用 SQL 语句进行角色创建，因为客户角色和商家角色 都是普通角色，因此除了登录的功能之外其他的高级权限都为 no。 创建客户角色的 SQL 语句：  CREATE ROLE "R_Customer" WITH  LOGIN  NOSUPERUSER  NOCREATEDB  NOCREATEROLE  NOINHERIT  NOREPLICATION  CONNECTION LIMIT-1  创建客户角色的 SQL 运行界面如图 2-3 所示。  图 2-3 创建客户角色 创建商家角色的 SQL 语句：  CREATE ROLE "R_Seller" WITH  LOGIN  NOSUPERUSER  NOCREATEDB  NOCREATEROLE  NOINHERIT  NOREPLICATION  CONNECTION LIMIT-1 创建商家角色的运行界面如图 2-4 所示。  图 2-4 创建商家角色 创建两个角色的结果展示如图 2-5 所示。  图 2-5 完成创建两个角色 结果分析：在角色用户表中看到 R_Customer,R_Seller，角色创建成功。 3.赋予客户、商家角色权限 实现思路与方法：使用 SQL 语句给两个角色赋予在步骤 1 定义的权限。 赋予客户角色 SQL 语句：  GRANT SELECT ON book TO "R_Customer";  GRANT SELECT ON auther TO "R_Customer";  GRANT SELECT ON publisher TO "R_Customer"; 运行界面如图 2-6 所示。  图 2-6 赋予客户角色权限 赋予商家角色 SQL 语句：  GRANT SELECT,INSERT,UPDATE,DELETE ON book TO "R_Seller";  GRANT SELECT,INSERT,UPDATE,DELETE ON auther TO "R_Seller";  GRANT SELECT,INSERT,UPDATE,DELETE ON publisher TO "R_Seller";  GRANT SELECT ON stock TO "R_Seller";  GRANT SELECT,INSERT,UPDATE,DELETE ON sale TO "R_Seller";  GRANT SELECT,INSERT,UPDATE,DELETE ON customer TO "R_Seller"; 运行界面如图 2-7 所示。  图 2-7 赋予商家角色权限 结果分析：权限赋予成功。 4.创建客户用户和商家用户，并将客户角色和商家角色赋予他们 实现思路与方法：使用 SQL 语句创建用户，并将对应的角色赋予他们。其 SQL 语句如下。  CREATE USER "U_Customer" WITH  LOGIN  CONNECTION LIMIT-1  IN ROLE "R_Customer"  PASSWORD'123456'; CREATE USER "U_Seller" WITH  LOGIN CONNECTION LIMIT-1  IN ROLE "R_Seller"  PASSWORD'123456'; SQL 运行界面如图 2-8 所示。  图 2-8 创建两个用户 运行结果如图 2-9 所示。  图 2-9 完成创建两个用户 结果分析：在角色用户表中发现 U_Customer,U_Seller，创建用户成功。 5.分别用客户用户和商家用户登录数据库，并进行操作来验证是否赋予权限 成功。 实现思路与方法：用客户用户和商家用户进行登录，通过对各表进行增删查 改操作来观察操作结果来验证是否与赋予他们的权限一致。 首先我们来登录客户用户来进行测试。 登录客户用户如图 2-10 所示。  图 2-10 登录客户用户 测试一：查看 book 表 SQL 语句：select*from book 运行界面和结果展示如图 2-11 所示。  图 2-11 客户用户查看 book 表数据 结果分析：客户用户可查看 book 表，权限正确。 测试二：删除 book 表中的数据 SQL 语句：delete from book where book_isbn= '9787115502742' 运行界面和结果展示如图 2-12 所示：  图 2-12 客户用户删除 book 表数据 结果分析：删除失败，客户用户不具有删除 book 表中数据的权限，权限正 确。 测试三：查看 auther 表 SQL 语句：select*from auther 运行界面和结果展示如图 2-13 所示。  图 2-13 客户用户查看 auther 表 结果分析：客户用户可查看 auther 表，权限正确。 测试四：插入一条数据到 auther 表中 SQL 语句： insert intoauther values('330304198802150325','李天','男','12365748953','北京 市产阳区李二路 18555 号') 运行界面如图 2-14 所示。  图 2-14 客户用户插入一条新数据到 auther 表 结果分析：客户用户无法在 auther 表中插入数据，权限正确。 测试五：查看 sale 表 SQL 语句：select*from sale 运行界面如图 2-15 所示。  图 2-15 客户用户查看 sale 表 结果分析：客户用户无查看销售表的权限，权限正确。五个测试均验证通过， 测试客户用户的权限正确。 测试完客户用户之后，我们登录商家用户来进行下一步的测试。 登录商家用户如图 2-16 所示。  图 2-16 登录商家用户 测试一：查看 customer SQL 语句：select*from customer 运行界面和结果展示如图 2-17 所示。  图 2-17 商家用户查看 customer 表 结果分析：商家用户具有查看客户表的权限，权限正确。 测试二：插入一条数据到 auther 中 SQL 语句：  insert into auther values('330304198802150325','李天','男','12365748953','北京 市产阳区李二路 18555 号') 运行界面如图 2-18 所示。  图 2-18 商家用户插入一条新数据到 auther 表 通过查看 auther 表进行结果展示如图 2-19 所示。  图 2-19 商家用户查询插入一条新数据后的 auther 表 结果分析：auther 表中新增了如上插入的数据，商家用户具有插入 auther 表 数据的权限，权限正确。 测试三：从 stock 表中删除一条数据 SQL 语句： delete from stock where stock_id='SA00001' 运行界面如图 2-20 所示。  图 2-20 商家用户删除一条 stock 表数据 结果分析：商家用户不具有删除 stock 表数据的权限，权限正确。 测试四：更新 sale 表的一条数据 SQL 语句： UPDATE sale SET sale_date='2019-05-21' WHERE sale_id='SA00001' 运行界面如图 2-21 所示。  图 2-21 商家用户更新一条 sale 表数据  结果展示，通过查看 sale 来查看结果如图 2-22 所示。  图 2-22 商家用户查看 sale 表数据 结果分析：sale 表中对应的数据被修改正确，商家用户具有修改 sale 数据的权限，权限正确。通过四个测试，每个测试结果都正确，说明商家用户权限赋予正确 九、总结及心得体会 这次实验主要是对角色与用户的权限赋予和检测这些权限的语句。这次实验比起实验一来说，我觉得要更加的简单，但是也向我介绍数据库的一些基本知识，让我知道权限的种类有这么多，对以后的数据库开发有更大的益处。这些角色的创建与赋予权限也让数据库有更大的灵活性。这个实验虽然基础但却很重要，希望以后能再次做到这样的实验。